LeetCode 283

相同数字后移



给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

 

示例 1:

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:

输入: nums = [0]
输出: [0]


提示:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1


进阶：你能尽量减少完成的操作次数吗？

```c
#include <stdio.h>

void moveZeroes(int arr[], int n){
    int zeros = 0;
    int i;
    for (i=0; i<n; i++){
        if (arr[i] !=0){
            arr[i-zeros] = arr[i];
        }
        else {
            zeros++;
        }
    }
    i = n - zeros;
    while (i<n) {
        arr[i] = 0;
        i++;
    }
}
//可以用来做快速排序法
void moveZeroes2(int arr[], int n) {
    int j = 0;
    int i;
    for (i=0; i<n; i++) {
        if (arr[i] != 0) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            j++;
        }
    }
}

int main() {
    int arr[8] = {1, 7, 0, 2, 3, 0, 4, 8};
    moveZeroes(arr, 8);
    int i;
    for (i=0; i<8; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

1、特殊矩阵可以，稀疏矩阵不可以，存储矩阵的一般方法是采用二维数组，其优点是可以随机地访问每一个元素，对称矩阵、三角矩阵、对角矩阵的压缩存储方法是把分布有规律的特殊元素压缩存储到一个存储空间，只需要在算法中按照公式做映射就可以实现矩阵元素的随机存取；稀疏矩阵采用三元组顺序表存储后会丧失随机存取特性

2、优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性；缺点：递归算法的运行效率较低，占用内存空间多，不容易优化

3、完全二叉树第六层8个叶结点，则第七层缺少16个结点不满，结点个数等于$2^7 -1-16=111$

4、满二叉树高度最小，即所有的叶子结点都在最下面一层，又非空二叉树第i层最多有$2^{i-1}$个结点，则100个叶子结点在第7层，即最小高度为7

5、假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：

(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；

(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；

(3)从森林中删除选取的两棵树，并将新树加入森林；

(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

在构建哈夫曼树时，必须遵循权重越大的结点距离树根越近的原则